---
title: "HW5"
format: html
editor: visual
---

## Stats 506 Homework #5

Margaret Miles

## Problem #1: **OOP Programming**

Create a class to represent Wald-style normal approximation Confidence Intervals. Do this using S4.

a.  For the `waldCI` class, define the following:

    a.  A constructor, which takes in either a mean and standard deviation, or a lower and upper bound along with a confidence level. This should be a custom constructor, not `new()` or `waldCI()`.

    b.  A validator.

    c.  A show method.

    d.  Accessors: `lb`, `ub`, `mean`, `sterr`. 

    e.  Setters: `lb`, `ub`, `mean`, `sterr`. Be sure to validate the resulting `waldCI`. 

    f.  A contains method, returning a logical of whether a value is within a CI.

    g.  An overlap method, that takes in two waldCI’s, and returns a logical of whether the two confidence intervals overlap.

    h.  as.numeric to return c(lb, ub). (Hint: The second argument of setGeneric is not needed when an existing s3 function uses the .Primitive function.)

    i. transformCI which takes in a function and a waldCI, and returns the transformed waldCI object. Warn the user that only monotonic functions make sense.

All `level` arguments should have a reasonable default value. `digits` as well.

```{r}
##' @title create waldCI class using S4
setClass("waldCI",
         slot = c(
           mean = "numeric",
           sterr = "numeric",
           lb = "numeric",
           ub = "numeric",
           level = "numeric"
         ))

##' @title make a constructor 
##' @param mean Numeric
##' @param sterr Numeric
##' @param lb numeric
##' @param ub numeric
##' @param level numeric
##' @return new `waldCI` object
makeWaldCI <- function(mean = NULL, sterr = NULL, 
                       lb = NULL, ub = NULL, level = 0.95){
  # for just mean and sterr
  if (!is.null(mean) && !is.null(sterr)) {
    # make Wald CI
    alpha <- 1 - level
    z <- qnorm(1 - alpha / 2)
    lb <- mean - z * sterr
    ub <- mean + z * sterr
  } else if (!is.null(lb) && !is.null(ub)) {
    # for CIs and level
    # made Wald CI
    mean <- (lb + ub) / 2
    alpha <- 1 - level
    z <- qnorm(1 - alpha / 2)
    sterr <- (ub - mean) / z
  } else {
    stop("Provide either (mean, sterr) or (lb, ub) and level.")
  }
  
  # Return the S4 object
  new("waldCI",
      mean = mean,
      sterr = sterr,
      lb = lb,
      ub = ub,
      level = level)
}

# validator!!!
##' @title create validator for WaldCI object
##' @param waldCI class object
setValidity("waldCI",  function(object) {
  # non-numeric
  if((!is.numeric(object@mean) || is.null(object@mean)) ||
     (!is.numeric(object@sterr) || is.null(object@sterr)) ||
     (!is.numeric(object@lb) || is.null(object@lb)) ||
     (!is.numeric(object@ub) || is.null(object@ub))){
    stop("A value is non-numeric, please enter only numeric values.")
  }
  
  # all null
  if(is.null(object@mean) && is.null(object@sterr) && is.null(object@lb) && is.null(object@ub)){
    stop("Missing all values, please enter values for CIs or Mean and sterr")
  }
  
  # if mean and sterr are null, but so is one of the CIs or level
  if (is.null(object@mean) && is.null(object@sterr) && 
      (is.null(object@lb) || is.null(object@lb) || is.null(object@level))) {
    stop("Missing either lb, ub, or level")
  }
  
  # if CIs are null but so is mean or sterr
  if (is.null(object@lb) && is.null(object@lb) && (is.null(object@mean) || is.null(object@sterr))) {
    stop("Missing either mean or sterr.")
  }
  
  # if level is not between 0 and 1
  if(object@level > 1 || object@level < 0){
    stop("Level must be inbetween 0 and 1")
  }
  
  # if error is negative
  if(object@sterr < 0 && !is.null(object@sterr)){
    stop("Standard Error must be non-negative.")
  }
  
  # lower bound and upper bound error
  if (object@lb >= object@ub)
      return("Lower bound must be less than upper bound.")
  
  # bounds must be finite
  if (!is.finite(object@lb) || !is.finite(object@ub))
      return("Bounds must be finite numbers.")
  
  # mean is not in between bounds
  if (!is.null(object@mean)){
    if(object@mean > object@ub || object@mean < object@lb){
      return("Mean cannot exceed the current bounds")
    }
  }
  
  return(TRUE)
  
})
  
# A `show` method, which takes as arguments `level` and `digits`
##' @title a show method for a `waldCI` object
##' @param object a `waldCI` object
setMethod("show", "waldCI",
          function(object){
            digits = 3
            cat("Wald-style Confidence Interval\n")
            cat("Level: ")
            cat(object@level)
            cat("\nMean: ", round(object@mean, digits))
            cat("\nStandard Error: ", round(object@sterr,digits))
            cat("\nLower Bound: ", round(object@lb, digits))
            cat("\nUpper Bound: ", round(object@ub, digits))
            cat("\n\n")
            return(invisible(object))
          })

# Accessors
# `lb`, `ub`, `mean`, `sterr`,`level`.

setGeneric("lb", function(object){
  standardGeneric("lb")
})
##' @title Return the lower bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's lower bound
setMethod("lb", "waldCI", function(object){
  return(slot(object, "lb"))
})

setGeneric("ub", function(object){
  standardGeneric("ub")
})
##' @title Return the upper bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's upper bound
setMethod("ub", "waldCI", function(object){
  return(slot(object, "ub"))
})

setGeneric("mean", function(object){
  standardGeneric("mean")
})
##' @title Return the mean of a `waldCI`
##' @param object A `waldCI` object
##' @return It's mean 
setMethod("mean", "waldCI", function(object){
  return(slot(object, "mean"))
})

setGeneric("sterr", function(object){
  standardGeneric("sterr")
})
##' @title Return the standard error of a `waldCI` object
##' @param object A `waldCI` object
##' @return It's standard error
setMethod("sterr", "waldCI", function(object){
  return(slot(object, "sterr"))
})

setGeneric("level", function(object){
  standardGeneric("level")
})
##' @title Return the lower bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's lower bound
setMethod("level", "waldCI", function(object){
  return(slot(object, "level"))
})

# setters
# Setters: `lb`, `ub`, `mean`, `sterr`. Be sure to validate the resulting `waldCI`. 

setGeneric("lb<-",
           function(object, value) {
             standardGeneric("lb<-")
           })

##' @title Set the lower bound of a `waldCI`
##' @param object A `waldCI` object
##' @param value New lower bound
##' @return The updated waldCI
setMethod("lb<-", "waldCI",
  function(object, value) {
    object@lb <- value
    validObject(object) # Re-run validity check
    updated <- makeWaldCI(ub = object@ub, lb = value, level = object@level)
    return(updated)
  }
)

setGeneric("ub<-",
           function(object, value) {
             standardGeneric("ub<-")
           })

##' @title Set the upper bound of a `waldCI`
##' @param object A `waldCI` object
##' @param value New upper bound
##' @return The updated object
setMethod("ub<-", "waldCI",
  function(object, value) {
    object@ub <- value
    validObject(object) # Re-run validity check
    updated <- makeWaldCI(ub = value, lb = object@lb, level = object@level)
    return(updated)
  }
)

setGeneric("mean<-",
           function(object, value) {
             standardGeneric("mean<-")
           })

##' @title Set the mean of a `waldCI`
##' @param object A `waldCI` object
##' @param value mean
##' @return The updated object
setMethod("mean<-", "waldCI",
  function(object, value) {
    object@mean <- value
    validObject(object) # Re-run validity check
    updated <- makeWaldCI(mean = value, sterr = object@sterr, level = object@level)
    return(updated)
  }
)

setGeneric("sterr<-",
           function(object, value) {
             standardGeneric("sterr<-")
           })

##' @title Set the standard error of a `waldCI`
##' @param object A `waldCI` object
##' @param value New standard error
##' @return The updated object
setMethod("sterr<-", "waldCI",
  function(object, value) {
    object@sterr <- value
    validObject(object) # Re-run validity check
    updated <- makeWaldCI(mean = object@mean, sterr = value, level = object@level)
    return(updated)
  }
)

setGeneric("level<-",
           function(object, value) {
             standardGeneric("level<-")
           })

##' @title Set the confidence level of a `waldCI`
##' @param object A `waldCI` object
##' @param value New level
##' @return The updated object
setMethod("level<-", "waldCI",
  function(object, value) {
    object@level <- value
    validObject(object) # Re-run validity check
    updated <- makeWaldCI(mean = object@mean, sterr = object@sterr, ub = object@ub,
                          lb = object@lb, level = object@level)
    return(updated)
  }
)

# A contains method, returning a logical of whether a value is within a CI.
setGeneric("contains", function(object, value) {
  standardGeneric("contains")
  })

##' @title a contains method
##' @param object A `waldCI` object
##' @param value a value to test whether it is in a CI
##' @return logical 
setMethod("contains", "waldCI", function(object, value) {
  value >= object@lb && value <= object@ub
})

# An overlap method, that takes in two waldCI’s, and returns a logical of whether the two confidence intervals overlap.
setGeneric("overlap", function(object1, object2) {
  standardGeneric("overlap")
  })

##' @title a overlap method
##' @param object1 A `waldCI` object
##' @param object2 another `waldCI` object
##' @return logical 
setMethod("overlap", "waldCI", function(object1, object2) {
  return(!(object1@ub < object2@lb || object2@ub < object1@lb))
})


# as.numeric to return c(lb, ub). (Hint: The second argument of setGeneric is not needed when an existing s3 function uses the .Primitive function.)

# have to use x
# asked chatGPT why

##' @title an as.numeric to return the lower and upper bound of the object
##' @param x A `waldCI` object
##' @return c(lb, ub) of a `waldCI` object
setMethod("as.numeric", "waldCI", function(x){
  return(c(x@lb, x@ub))
  })

# transformCI which takes in a function and a waldCI, and returns the transformed waldCI object. Warn the user that only monotonic functions make sense.
setGeneric("transformCI", function(object, func) {
  standardGeneric("transformCI")
  })

##' @title a transformCI which returns a transformed WaldCI object
##' @param object A `waldCI` object
##' @param func a function
##' @return a transformed `waldCI` object
setMethod("transformCI", c("waldCI", "function"), function(object, func){
  warning("Only monotonic functions are allowed and will make sense.")
  translb <- func(object@lb)
  transub <- func(object@ub)
  transmean <- func(object@mean)
  # need to calculate SE again 
  alpha <- 1 - object@level
  z <- qnorm(1 - alpha / 2)
  transsterr <- (transub - transmean) / z 
  
  if(!is.numeric(translb) || !is.numeric(transub) || !is.numeric(transsterr) || !is.numeric(transmean)) {
    stop("Values are now non-numeric. Doesn't work.")
  }
  
  if(is.null(transsterr) || is.null(translb) || is.null(transub) || is.null(transmean)){
    stop("Function produced NULL results.")
  }
  
  if(is.na(transsterr) || is.na(translb) || is.na(transub) || is.na(transmean)){
    stop("Produced NAs.")
  }
  
  if(translb == object@lb && transub == object@ub || transmean == object@mean){
    stop("Function didn't make sense. Did not change values.")
  }
  new1 <- makeWaldCI( mean = transmean, sterr = transsterr, lb = translb,
      ub = transub, level = object@level)
  validObject(new1) 
  return(new1)
  })

```

b\. Use your `waldCI` class to create three objects:

-   `ci1`: (17.2, 24.7), 95%

-   `ci2`: mean: 13, standard error: 2.5, 99%

-   `ci3`: , 75%

```{r}
# construct from CIs and level
ci1 <- makeWaldCI(lb = 17.2, ub = 24.7, level = 0.95)

# Construct from mean and SE
ci2 <- makeWaldCI(mean = 13, sterr = 2.5, level = 0.99)

# for new CI and level
ci3 <- makeWaldCI(lb = 27.43, ub = 39.22, level = 0.75)

ci1
ci2
ci3
print("Prints out CIs as expected")

cat("\n")
as.numeric(ci1)
cat("\n")
as.numeric(ci2)
cat("\n")
as.numeric(ci3)
print("Prints out numeric as expected.")

lb(ci2)
ub(ci2)
mean(ci1)
sterr(ci3)
level(ci2)
print("Prints accessors as expected.")

lb(ci2) <- 10.5
ci2
print("Changes the lb, recalculates mean and standard error")
mean(ci3) <- 34
ci3
print("Changes the mean, recalculates lb and ub")
level(ci3) <- .8
ci3
print("Changes the level, recalculates the lower and upper bound only")


contains(ci1, 17)
contains(ci3, 44)
overlap(ci1, ci2)

eci1 <- transformCI(ci1, sqrt)
eci1
mean(transformCI(ci2, log))
```
All of these work as intended and shown above.


c\. Show that your validator does not allow the creation of invalid confidence intervals:

-   negative standard error

-   lb \> ub

-   Infinite bounds

-   invalid use of the setters

```{r}
# found try() from ChatGPT
# negative standard error
try(ci4 <- makeWaldCI(mean = 10, sterr = -1, level = 0.95))
try(ci4 <- makeWaldCI(mean = 10, sterr = -10))

# lb > ub
try(ci4 <- makeWaldCI(lb = 47.43, ub = 39.22, level = 0.75))
try(ci4 <- makeWaldCI(lb = 0, ub = 0, level = 0.75))


# Infinite bounds
try(ci4 <- makeWaldCI(lowerCI = -Inf, upperCI = 10, level = 0.95))
try(ci4 <- makeWaldCI(lowerCI = 0, upperCI = Inf, level = 0.95))

# invalid use of the setters

# Attempt to set a negative SE
try(sterr(ci1) <- -5)
# Attempt to set lb > ub
try(lb(ci1) <- 20)
# Attempt to set an infinite upper bound
try(ub(ci1) <- Inf)
# attempt a mean outside of the bounds
try(mean(ci1) <- 35)

# trying transform
try(ci4 <- transformCI(ci1, acos))
try(ci4 <- transformCI(ci1, tanpi))
try(ci4 <- transformCI(ci1, stderr))
try(ci4 <- transformCI(ci1, sum))
try(ci4 <- transformCI(ci1, ncol))
try(ci4 <- transformCI(ci1, max))
try(ci4 <- transformCI(ci1, log2))
try(ci4 <- transformCI(ci1, is.object))
try(ci4 <- transformCI(ci1, cos))
try(ci4 <- transformCI(ci1, sin))
try(ci4 <- transformCI(ci1, abs))
```

Note that there are a lot of choices to be made here. What are you going to store in the class? How are you going to store them (what object types)? How are you going to enforce the function in `transform` being monotonic?

There is no right answer to those questions. Make the best decision you can, and don’t be afraid to change it if your decision causes unforeseen difficulties.

You may not use any existing R functions or packages that would trivialize this assignment. (E.g. if you found an existing package that does this, or found a function that checks for overlap between two CIs, that is not able to be used.)

Hint: It may be useful to define other functions that I don’t explicitly ask for.

## Problem #3: **plotly**

Repeat problem set 4, question 3 using plotly.

There is no expectation that you produce the exact same plots as last time. You may of course use your plots as last time, or the ones from the problem set 4 solutions, as inspiration for these plots.

These will be graded similar to last time:

Is the type of graph & choice of variables appropriate to answer the question?
Is the graph clear and easy to interpret?
Is the graph publication ready?

Note: This is, intentionally, a very open-ended question. There is no “right” answer. The goal is for you to explore your plotting options, and settle on something reasonable. You can use base R, ggplot, or something else. You’ll likely have to look online for resources on plotting beyond what we covered in class.

Use the NYTimes Covid data (https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv). This lists daily Covid new cases. For each of the following, produce a publication-ready plot which addresses the question. Use your plot to support an argument for your question.

Based on last homework, assume that the us-states-covid.csv is already downloaded and in the project. 

a. How many major and minor spikes in cases were there?

```{r}
library(tidyverse)
library(plotly)

covid <- read_csv("us-states-covid.csv")

# a major peak is defined as a peak 2SD+
# a minor peak is defined as a peak 1SD+
full_national <- covid %>%
  # sum all cases from the same day
  group_by(date) %>%
  summarize(total_avg_cases = sum(cases_avg, na.rm = TRUE), 
            total_cases = sum(cases, na.rm = TRUE),
            .groups = "drop")

# plot(full_national$total_avg_cases)
# plot(full_national$total_cases)

mean_national <- base::mean(full_national$total_avg_cases, na.rm = TRUE)
sd_national   <- sd(full_national$total_avg_cases, na.rm = TRUE)

full_national <- full_national %>%
  mutate(
    z_score  = (total_avg_cases - mean_national) / sd_national
  )

# mark as major and minor peak
full_national <- full_national %>%
  mutate(peak_type = case_when(
    (z_score > 0 & z_score < 2) ~ "minor",
    (z_score > 2) ~ "major",
    TRUE ~ NA))

table(full_national$peak_type, useNA = "ifany")

# group major and minors together in the same timing
# Identify peaks and assign interval groups
peak_number = 1
full_national <- full_national %>%
  # create a change marker for each peak change grouping
  mutate(peak_group = NA,
         peak_change = (peak_type != lag(peak_type))) #%>%
  # cumulative sum of changes gives a unique group ID
  # mutate(peak_group = ifelse(!is.na(peak_type_char), cumsum(peak_change), NA_integer_))
table(full_national$peak_type)
summary(full_national$peak_change)

# plot using plotly
plot1 <- full_national %>%
  plot_ly(x = ~date, y = ~total_avg_cases, type = 'scatter', mode = 'lines',
          name = 'Sum of Total Avg. Cases per day', hoverinfo = 'x+y') %>%
  layout(title = 'Total US Avg. Cases of COVID per day with Peaks Marked',
         xaxis = list(title = 'Date'),
         yaxis = list(title = 'Sum of Total Avg. Cases for Date'))

# add markers and annotations for peaks


# add color different for major vs minor 
# label each interval of major or minor only once
plot1 <- plot1 %>%
    add_trace(data = peak_rows, x = ~date, y = ~total_avg_cases,
    type = 'scatter', mode = 'markers+text',
    text = ~peak_type, textposition = 'top center',
    marker = list(size = 10, color = ~ifelse(peak_type == "major", "red", "orange")),
    name = 'Peaks')

plot1

```

b. For the states with the highest and lowest overall rates per population, what differences do you see in their trajectories over time?

```{r}

```

c. Identify, to the best of your ability without a formal test, the first five states to experience Covid in a substantial way.

```{r}

```


